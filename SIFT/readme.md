尺度不变特征转换(Scale-invariant feature transform 或 SIFT)是一种机器视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变数。
SIFT算法步骤：
尺度空间极值检测
关键点定位
关键点方向参数
关键点描述符
关键点匹配
尺度空间极值检测：

对基本原理的理解
尺度空间
尺度空间，就相当于一个图片需要获得多少分辨率的量级。如果把一个图片从原始分辨率到，不停的对其分辨率进行减少，然后将这些图片摞在一起，可以看成一个四棱锥的样式，这个东西就叫做图像金字塔。
在摄像头中，计算机无法分辨一个景物的尺度信息。而人眼不同，除了人大脑里已经对物体有了基本的概念（例如正常人在十几米外看到苹果，和在近距离看到苹果，都能认出是苹果）以外，人眼在距离物体近时，能够获得物体足够多的特性，在距离物体远时，能够或略细节，例如，近距离看一个人脸能看到毛孔，距离远了看不到毛孔等等。
在图片信息当中，分辨率都是固定的，要想得到类似人眼的效果，就要把图片弄成不同的分辨率，制作成图像金字塔来模拟人眼的功能，从而在其他图片中进行特征识别时，能够像人眼睛一样，即使要识别的物体尺寸变大或者变小，也能够识别出来。


在SIFT当中，利用了一个叫做高斯核的方程来构建尺度空间，原因是高斯核函数是唯一多尺度空间的核。听起来比较晦涩，个人理解为：
高斯核函数在之前的高斯滤波当中使用过，其原理就是利用高斯分布的特性，在以某一个点为中心要进行以某一个窗口大小进行模糊的操作。那么，根据滤波的原理，距离中心像素点位置的距离越远的像素点，需要“模糊化效果”的值就应该越少。那么这个距离值的分配方法，就是利用满足高斯核函数的分配方法，由中心，到四周，符合高斯核函数的“钟型”曲线（从二维上看）。
那么尺度空间中的高斯核也可以这么理解，高斯核函数的参数有三个G(x,y,σ) ，在滤波当中，第三个参数σ在运算中是固定的一个值。而在尺度空间的构造当中，所谓的“尺度”，就是这个σ值变化，而x和y表示像素坐标。σ的值越小，图像被平滑（被模糊）的越少，尺度也越小。所以，大尺度图片可以对应成一个图像离远处观看，是个大致轮廓，小尺度图片可以对应成离近处观看，有更多细节。
构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，如此可以获得缩放不变性

其中利用图像I(x,y)与G(x,y,σ) 进行卷积运算，得到尺度空间L(x,y,σ)，可以理解，所谓的“尺度空间”在这里就是这个函数L(x,y,σ)
如果求取特征点，可以使用一个叫做拉普拉斯算子进行运算
但是，由于拉普拉斯算子的效率太低，再SIFT算法当中使用差分来代替。

高斯金字塔：
在建立尺度空间后，需要找到关键点，此时需要实现高斯金字塔的构造来实现关键点的求取。在高斯金字塔当中，“塔”的每一层都是图像，“塔”的高度就是上面提到的尺度σ。“塔”的每一层对应一个σ值，同时将高斯金字塔中的图像分成组，每组当中图像的尺寸相同，但是尺度σ不同。具体尺度之间的计算关系，先忽略，如下图所示：


高斯差分金字塔DOG：
每一组相邻当中相邻两层的图像做差，得到的图像再“叠”成一个金字塔就是高斯差分金字塔DOG。

DOG局部特征点检测：
有了差分金字塔，现在便可以计算关键点（特征点）。由于金字塔的模型不是二维模型，而是一个三维模型，这里计算极值的方法也不再是二维求取极值的方法。
计算一个某一个点是否是局部最大值，在离散的三维空间当中，以该点为中心，检测它周围的点。类似魔方的中心位置一样，如下图中的“叉”就是待计算是否是局部极值点。

这里说明，局部极值点都是在同一个组当中进行的，所以肯定有这样的问题，某一组当中的第一个图和最后一个图层没有前一张图和下一张图，那该怎么计算？ 解决办法是，在用高斯模糊，在高斯金字塔多“模糊”出三张来凑数，所以在DOG中多出两张。

关键点定位：
上面找到的关键点要进行处理，去除一些不好的特征点，保存下来的特征点能够满足稳定性等条件。
主要是去掉DOG局部曲率非常不对称的像素。
因为低对比度的特征点和边界点对光照和噪声变化非常敏感，所以要去掉。利用阈值的方法来限制，在opencv中为contrastThreshold。

去除低对比度的特征点：
使用泰勒公式对DOG函数空间进行拟合，去掉小于修正阈值的关键点。

去除不稳定的边界点：
利用Hessian矩阵（就是求导数的矩阵），利用边缘梯度的方向上主曲率值比较大，而沿着边缘方向则主曲率值较小的原理，将主曲率限制为某个值。满足该值条件的点留下，反之去除。

关键点设定方向参数：
每个关键点设置方向以后可以获得旋转不变性。
获取关键点所在尺度空间的邻域，然后计算该区域的梯度和方向，根据计算得到的结果创建方向直方图，直方图的峰值为主方向的参数，其他高于主方向百分之80的方向被判定为辅助方向，这样设定对稳定性有很大帮助。

关键点描述符：
经过上面的步骤计算，每个关键点有三个信息，位置、尺度、方向。所以具备平移、缩放、和旋转不变性。
接下来对每个关键点用一组向量将这个关键点描述出来，使其不随着光照、视角等等影响而改变。该描述符不但涉及关键点，而且还涉及到关键点周围的像素，使其有更强的不变特性。

基本原理是选取关键点周围16×16的像素区域，分成4个小块，每个小块创建8个bin的直方图，这总共的128个信息的向量就是关键点描述符的主要内容。此外还要测量，以达到光照、旋转的稳定性。

关键点匹配：
分别对模板图和实时图建立关键点描述符集合，通过对比关键点描述符来判断两个关键点是否相同。128个信息的向量使用欧氏距离来实现。
在关键点的匹配当中，使用的搜索算法为区域搜索算法当中最常用的k-d树实现。
比较之后，需要在进行消除错配点才算完成。
OpenCV 中的 SIFT：
关于opencv版本与SIFT算法不能调用的问题：
SIFT算法是一个有专利的算法，在商业用途上是收费的。不过，在python当中使用SIFT算法和版本之间有不少关系，源文档当中使用opencv版本是2.4.9版本，此版本可以随意使用SIFT算法。
但是，在opencv3当中就没那么幸运了，opencv中的很多特征点提取算法都和cv2中的库分离开，必须要添加opencv-contrib才可以使用。
